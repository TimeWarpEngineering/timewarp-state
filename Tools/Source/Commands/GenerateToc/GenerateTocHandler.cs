namespace Tools.Commands.GenerateToc
{
  using System;
  using System.Collections.Generic;
  using System.IO;
  using System.Linq;
  using System.Text;
  using System.Text.RegularExpressions;
  using System.Threading;
  using System.Threading.Tasks;
  using MediatR;
  using Tools.Services;

  internal class GenerateTocHandler : IRequestHandler<GenerateTocRequest>
  {
    public GenerateTocHandler(GitService aGitService)
    {
      GitService = aGitService;
    }
    const string AutoGeneratedTag = "auto-generated";
    const string TocFileName = "toc.yml";

    private List<string> IgnoreList { get; } = new List<string> { "api", "images", "_site", "Partials" };
    private GitService GitService { get; }

    public Task<Unit> Handle(GenerateTocRequest aRequest, CancellationToken aCancellationToken)
    {
      DirectoryInfo directory = GitService.GitRootDirectoryInfo();
      DirectoryInfo documentationDirectoryInfo = directory.GetDirectories("Documentation").FirstOrDefault();
      BuildTocs(documentationDirectoryInfo);
      return Unit.Task;
    }

    private void BuildTocs(DirectoryInfo aDirectoryInfo)
    {
      if (!IgnoreList.Contains(aDirectoryInfo.Name))
      {
        Console.WriteLine($"Checking Directory: {aDirectoryInfo.FullName}");
        bool hasManualToc = HasManualToc(aDirectoryInfo);
        if (aDirectoryInfo.GetFiles("*.md", SearchOption.AllDirectories).Any() && !hasManualToc)
        {
          BuildToc(aDirectoryInfo);
        }
        else
        {
          if (hasManualToc)
          {
            Console.WriteLine($"Has a manual {TocFileName} thus will not generate");
          }
          else
          {
            Console.WriteLine($"No Markdown files in this dir or any child directories so won't generate {TocFileName}");
          }
        };
        foreach (DirectoryInfo childDirectory in aDirectoryInfo.GetDirectories())
        {
          BuildTocs(childDirectory);
        }
      };
    }

    private bool HasManualToc(DirectoryInfo aDirectoryInfo)
    {
      FileInfo fileInfo = aDirectoryInfo.GetFiles(TocFileName).FirstOrDefault();
      if (fileInfo == null)
        return false;
      using (StreamReader streamReader = fileInfo.OpenText())
      {
        return !streamReader.ReadLine().Contains(AutoGeneratedTag);
      }
    }

    private void BuildToc(DirectoryInfo aDirectoryInfo)
    {
      var builder = new StringBuilder();
      // Add files in this dir
      Console.WriteLine($"Generate the {aDirectoryInfo.FullName}/{TocFileName} for ");

      //builder.AppendLine($"# {AutoGeneratedTag}");
      foreach (FileInfo aFileInfo in aDirectoryInfo.GetFiles("*.md"))
      {
        AddEntry(builder, ConvertToDisplayName(aFileInfo), aFileInfo.Name);
      }

      // Add references to child dirs
      foreach (DirectoryInfo childDirectory in aDirectoryInfo.GetDirectories())
      {
        if (!IgnoreList.Contains(childDirectory.Name) && childDirectory.GetFiles("*.md", SearchOption.AllDirectories).Any())
        {
          AddEntry(builder, childDirectory.Name, $"{ childDirectory.Name}/{TocFileName}");
        }
      }
      builder.Insert(0, $"# {AutoGeneratedTag}{Environment.NewLine}");
      Console.Write(builder.ToString());
      File.WriteAllText($"{aDirectoryInfo.FullName}/{TocFileName}", builder.ToString(), Encoding.UTF8);
    }

    private static void AddEntry(StringBuilder aStringBuilder, string aName, string aHref)
    {
      if (aName.Contains("Overview")) // Put Overview first Insert at the top
      {
        aStringBuilder.Insert(0, $"  href: {aHref}{Environment.NewLine}");
        aStringBuilder.Insert(0, $"- name: {aName}{Environment.NewLine}");
      }
      else
      {
        aStringBuilder.AppendLine($"- name: {aName}");
        aStringBuilder.AppendLine($"  href: {aHref}");
      }
    }

    private string ConvertToDisplayName(FileInfo aFileInfo)
    {
      string name = Path.GetFileNameWithoutExtension(aFileInfo.Name);
      string[] words = Regex.Matches(name, Constants.SplitStringRegEx)
          .OfType<Match>()
          .Select(aMatch => aMatch.Value.TrimEnd('-'))
          .ToArray();
      string result = string.Join(" ", words);
      result = result == "" ? name : result;
      return result;
    }


  }
}
